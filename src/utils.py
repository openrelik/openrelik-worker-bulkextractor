# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.d

import os
import glob
import xml.etree.ElementTree as xml_tree

from openrelik_worker_common.reporting import Report, MarkdownTable
from openrelik_worker_common.file_utils import create_output_file
from typing import List, Dict

def check_xml_attrib(xml_file, xml_key):
    """Checks if a key exists within the xml report.

        Args:
            xml_key(str): the xml key to check for.

        Returns:
            xml_hit(str): the xml value else return N/A.
        """
    xml_hit = 'N/A'
    xml_search = xml_file.find(xml_key)

    # If exists, return the text value.
    if xml_search is not None:
        xml_hit = xml_search.text
    return xml_hit

def generate_summary_report(output_dir):
    """Generate a summary report from the resulting bulk extractor run.

    Args:
        output_file_path(str): the path to the bulk extractor output.

    Returns:
        tuple: containing:
        report_test(str): The report data
        summary(str): A summary of the report (used for task status)
    """
    features_count = 0
    report_path = os.path.join(output_dir, 'report.xml')

    # Check if report.xml was not generated by bulk extractor.
    if not os.path.exists(report_path):
        report = 'Execution successful, but the report is not available.'
        return (report, report)

    # Parse existing XML file.
    xml_file = xml_tree.parse(report_path)
    report = Report("Bulk Extractor Results")

    # Place in try/except statement to continue execution when
    # an attribute is not found and NoneType is returned.
    try:
        # Retrieve summary related results.
        section = report.add_section()
        section.add_header("Run Summary")
        section.add_bullet(
                'Program: {0} - {1}'.format(
                    check_xml_attrib(xml_file,'creator/program'),
                    check_xml_attrib(xml_file,'creator/version')))
        section.add_bullet(
                'Command Line: {0}'.format(
                    check_xml_attrib(
                        xml_file,
                        'creator/execution_environment/command_line')))
        section.add_bullet(
                'Start Time: {0}'.format(
                    check_xml_attrib(
                        xml_file,
                        'creator/execution_environment/start_time')))
        section.add_bullet(
                f"Elapsed Time: {check_xml_attrib(xml_file, 'report/elapsed_seconds')}"
            )

        # Retrieve results from each of the scanner runs and display in table
        feature_files = xml_file.find(".//feature_files")
        scanner_results = []
        section = report.add_section()
        if feature_files is not None:
            section.add_header('Scanner Results\n')
            for name, count in zip(xml_file.findall(".//feature_file/name"),
                                    xml_file.findall(".//feature_file/count")):
                scanner_results.append({"Name": name.text, "Count": int(count.text)})
                features_count += int(count.text)
            sorted_scanner_results = sorted(
                scanner_results, key=lambda x: x["Count"], reverse=True)
            columns = scanner_results[0].keys()
            t = MarkdownTable(columns)
            for scanner_result in sorted_scanner_results:
                print([str(scanner_result[column]) for column in columns])
                t.add_row([str(scanner_result[column]) for column in columns])
            section.add_table(t)
        else:
            section.add_header("There are no findings to report.")
    except AttributeError as exception:
        raise exception
    report.summary = f'{features_count} artifacts have been extracted.'
    return report

def extract_non_empty_files(artifact_dir, output_path) -> List[Dict]:
    """Walks a firectory and returns a list of OutputFiles that are not empty
    
    Args:
        artifact_dir(str): The path of the directory to walk
        output_path(str): The path of the directory to store the results
    """
    out_dir = os.path.join(artifact_dir, "output")
    os.makedirs(out_dir, exist_ok=True)
    out_files = []
    for entry in glob.glob(os.path.join(artifact_dir, '**'), recursive=True):
        if os.path.exists(entry) and not os.path.isdir(entry):
            with open(entry, "rb") as f:
                content = f.read()
                if content:
                    out_file = create_output_file(output_path, display_name=os.path.basename(entry))
                    with open(out_file.path, "wb") as out_f:
                        out_f.write(content)
                    out_files.append(out_file.to_dict())
    return out_files